#include "pxt.h"

// There is no DAC on STM32F401

#define NOTE_PAUSE 20

enum class SoundOutputDestination {  
  //% block="Buzzer"
  Speaker = 0,
  //% block="P0"
  PinP0 = 1,
  //% block="P1"
  PinP1 = 2,
  //% block="P2"
  PinP2 = 3,
  //% block="P3"
  PinP3 = 4,  
  //% block="P8"
  PinP8 = 5,
  //% block="P12"
  PinP12 = 6,
  //% block="P16"
  PinP16 = 7,
};

static int Scale(double value, int originalMin, int originalMax, int scaleMin, int scaleMax) {
	auto scale = (double)(scaleMax - scaleMin) / (originalMax - originalMin);
	auto ret = (int)(scaleMin + ((value - originalMin) * scale));

	return ret > scaleMax ? scaleMax : (ret < scaleMin ? scaleMin : ret);
}

namespace music {

SoundOutputDestination soundOutputDestination = SoundOutputDestination::Speaker;
int vol = 127;

int LookupPinConvertToId(SoundOutputDestination p) {
	
	switch (p)
	{
		case SoundOutputDestination::Speaker:
			return (pxt::IsPulse() == true) ? PB_8 : -1;
			
		case SoundOutputDestination::PinP0:
			return PA_5;
			
		case SoundOutputDestination::PinP1:
			return PA_3;
			
		case SoundOutputDestination::PinP2:
			return PA_2;

		case SoundOutputDestination::PinP3:
			return (pxt::IsPulse() == true) ? PA_1 : -1;
			
		case SoundOutputDestination::PinP8:
			return (pxt::IsPulse() == true) ? PA_9 : -1;
			
		case SoundOutputDestination::PinP12:
			return (pxt::IsPulse() == true) ? PA_10 : PA_5;
			
		case SoundOutputDestination::PinP16:
			return (pxt::IsPulse() == true) ? -1 : PA_3;
	}
	
	return -1;
	
}

/**
 * Turn the on-board speaker on or off.
 * @param out the destination for sounds generated by the synthesizer
 */
//% weight=96
//% blockId=music_set_output block="set sound output on %out"
//% parts="speaker"
//% group="Sound"
void setOutput(SoundOutputDestination out) {
  if (out != soundOutputDestination) {
    soundOutputDestination = out;
  }
}

/**
* Play a tone through the speaker for some amount of time.
* @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C
* @param ms tone duration in milliseconds (ms), eg: BeatFraction.Whole
*/
//% help=music/play-tone
//% blockId=music_play_note block="play|tone %note=device_note|for %duration=device_beat"
//% parts="headphone" async
//% blockNamespace=music
//% weight=76 blockGap=8
//% group="Tone"
void playTone(int frequency, int ms) {
  int lookupPinId = LookupPinConvertToId(soundOutputDestination);
  
  if (lookupPinId < 0)
	  return;
  
  auto pitchPin = lookupPin(lookupPinId);

  if (frequency <= 0) {
    pitchPin->setAnalogValue(0);
  } else {
    //pitchPin->setAnalogValue(512);
	auto v = Scale(vol, 0, 255, 0, 1024);
	pitchPin->setAnalogValue(v);
    pitchPin->setAnalogPeriodUs(1000000 / frequency);
    if (ms > 0) {
      int d = max(1, ms - NOTE_PAUSE); // allow for short rest
      int r = max(1, ms - d);
      fiber_sleep(d);
      pitchPin->setAnalogValue(0);
      fiber_sleep(r);
    }
  }
}

/**
 * Set the default output volume of the sound synthesizer.
 * @param volume the volume 0...255
 */
//% blockId=synth_set_volume block="set volume %volume"
//% volume.min=0 volume.max=255
//% volume.defl=127
//% help=music/set-volume
//% weight=70
//% group="Volume"
//% blockGap=8
void setVolume(int volume) {
	auto pitchPin = lookupPin(soundOutputDestination == SoundOutputDestination::Speaker ? PB_8 : PA_5);
	
	auto v = Scale(volume, 0, 255, 0, 512);
	pitchPin->setAnalogValue(v);
	
	vol = volume;

} 

/**
 * Returns the current output volume of the sound synthesizer.
 */
//% blockId=synth_get_volume block="volume"
//% help=music/volume
//% weight=69
//% group="Volume"
//% blockGap=8
int volume() {
	return vol;
}

}